#!/usr/bin/env python3
"""
Visualize pseudo-labels generated by Official Grounding DINO on actual images.
Shows bounding boxes with class names and confidence scores.
"""
import json
from pathlib import Path
import cv2
import numpy as np
import random
import argparse
import sys

# Configuration
SCRIPT_DIR = Path(__file__).parent.parent
PSEUDO_LABELS_FILE = SCRIPT_DIR / "data/annotations/pseudo_labels_official.json"
IMAGE_DIR = SCRIPT_DIR / "data/unlabeled_images"
OUTPUT_DIR = SCRIPT_DIR / "data/visualizations_official"
NUM_IMAGES_TO_VISUALIZE = 10  # Number of random images to visualize

# Colors for bounding boxes (BGR format for OpenCV)
COLORS = [
    (0, 255, 0),    # Green
    (255, 0, 0),    # Blue
    (0, 0, 255),    # Red
    (0, 255, 255),  # Yellow
    (255, 0, 255),  # Magenta
    (255, 255, 0),  # Cyan
    (128, 0, 128),  # Purple
    (255, 165, 0),  # Orange
    (0, 128, 255),  # Light Blue
    (255, 192, 203) # Pink
]

def visualize_labels(json_file: Path, image_dir: Path, output_dir: Path, num_samples: int = 10):
    """Visualize pseudo-labels on images"""
    
    if not json_file.exists():
        print(f"‚ùå Error: Pseudo-labels file not found at {json_file}")
        print(f"\nLooking for files in: {json_file.parent}")
        existing = list(json_file.parent.glob("*.json"))
        if existing:
            print(f"\nFound these JSON files:")
            for f in existing:
                print(f"   - {f.name}")
        return
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print("=" * 70)
    print("VISUALIZING PSEUDO-LABELS")
    print("=" * 70)
    print(f"Loading labels from: {json_file}")
    
    with open(json_file, 'r') as f:
        data = json.load(f)
    
    images_info = {img['id']: img for img in data.get("images", [])}
    annotations = data.get("annotations", [])
    categories = {cat['id']: cat['name'] for cat in data.get("categories", [])}
    
    print(f"‚úÖ Loaded {len(images_info)} images, {len(annotations)} annotations, {len(categories)} categories\n")
    
    # Group annotations by image_id
    annotations_by_image = {}
    for ann in annotations:
        image_id = ann['image_id']
        if image_id not in annotations_by_image:
            annotations_by_image[image_id] = []
        annotations_by_image[image_id].append(ann)
    
    # Select random images to visualize
    image_ids_with_annotations = list(annotations_by_image.keys())
    if not image_ids_with_annotations:
        print("‚ùå No images with annotations to visualize.")
        return
    
    # Sample random images
    num_to_sample = min(num_samples, len(image_ids_with_annotations))
    sampled_image_ids = random.sample(image_ids_with_annotations, num_to_sample)
    
    print(f"üì∏ Visualizing {len(sampled_image_ids)} random images...")
    print(f"   Output directory: {output_dir}\n")
    
    for idx, img_id in enumerate(sampled_image_ids, 1):
        img_info = images_info.get(img_id)
        if not img_info:
            continue
        
        file_name = img_info['file_name']
        image_path = image_dir / file_name
        
        if not image_path.exists():
            print(f"‚ö†Ô∏è  Warning: Image file not found: {image_path}")
            continue
        
        # Load image
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"‚ö†Ô∏è  Warning: Could not read image: {image_path}")
            continue
        
        img_annotations = annotations_by_image.get(img_id, [])
        
        # Get unique classes for color assignment
        unique_classes = list(set([ann['category_id'] for ann in img_annotations]))
        class_to_color = {cat_id: COLORS[i % len(COLORS)] for i, cat_id in enumerate(unique_classes)}
        
        print(f"{idx}. {file_name}: {len(img_annotations)} annotations")
        
        # Draw annotations
        for ann in img_annotations:
            bbox = ann['bbox']  # [x, y, width, height]
            x, y, w, h = map(int, bbox)
            
            # Get class name
            category_id = ann['category_id']
            class_name = categories.get(category_id, f"Unknown_{category_id}")
            score = ann.get('score', 0.0)
            
            # Get color for this class
            color = class_to_color.get(category_id, (128, 128, 128))
            
            # Ensure coordinates are within image bounds
            x1, y1 = max(0, x), max(0, y)
            x2, y2 = min(img.shape[1], x + w), min(img.shape[0], y + h)
            
            # Draw bounding box
            cv2.rectangle(img, (x1, y1), (x2, y2), color, 3)
            
            # Prepare label text
            label_text = f"{class_name} {score:.2f}" if score else class_name
            
            # Calculate text size and position
            font = cv2.FONT_HERSHEY_SIMPLEX
            font_scale = 0.7
            thickness = 2
            (text_width, text_height), baseline = cv2.getTextSize(label_text, font, font_scale, thickness)
            
            # Position label above box (or below if too close to top)
            text_y = y1 - 10 if y1 - 10 > text_height + 10 else y2 + text_height + 10
            
            # Draw text background
            cv2.rectangle(img, 
                         (x1, text_y - text_height - 5),
                         (x1 + text_width + 10, text_y + 5),
                         color, -1)
            
            # Draw text
            cv2.putText(img, label_text, (x1 + 5, text_y), 
                       font, font_scale, (255, 255, 255), thickness)
        
        # Save visualization
        output_filename = f"vis_{file_name}"
        output_path = output_dir / output_filename
        cv2.imwrite(str(output_path), img)
        print(f"   ‚úÖ Saved: {output_path.name}")
    
    print(f"\n‚úÖ Visualizations saved to {output_dir}")
    print("\nüí° Please manually inspect these images to assess label quality!")
    print("=" * 70)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Visualize pseudo-labels on images")
    parser.add_argument("--labels", type=str, default=None,
                       help="Path to label JSON file (auto-detects if not provided)")
    parser.add_argument("--num-samples", type=int, default=10,
                       help="Number of random images to visualize (default: 10)")
    parser.add_argument("--output-dir", type=str, default=None,
                       help="Output directory for visualizations")
    
    args = parser.parse_args()
    
    # Determine label file
    if args.labels:
        label_file = Path(args.labels)
    else:
        # Auto-detect
        possible_paths = [
            SCRIPT_DIR / "data/annotations/pseudo_labels_official.json",
            SCRIPT_DIR / "data/annotations/pseudo_labels_official_test.json",
            SCRIPT_DIR / "mmdetection/data/annotations/pseudo_labels_full.json",
        ]
        
        label_file = None
        for path in possible_paths:
            if path.exists():
                label_file = path
                break
        
        if label_file is None:
            print("‚ùå Error: Could not find label file automatically.")
            print("\nPlease specify with --labels <path> or place file in one of:")
            for p in possible_paths:
                print(f"   - {p}")
            sys.exit(1)
    
    # Determine output directory
    if args.output_dir:
        output_dir = Path(args.output_dir)
    else:
        output_dir = OUTPUT_DIR
    
    visualize_labels(label_file, IMAGE_DIR, output_dir, args.num_samples)

